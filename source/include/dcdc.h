#ifndef __DCDC_H__
#define __DCDC_H__

#include "aips.h"

#define dcdc ((aips_1_s*)AIPS_1_OFFSET)->dcdc

#define DCDC_VDD_SOC_TO_TRG(mv) (((mv) - 800) / 25) // 25mV increments from 0.8v
#define DCDC_TRG_TO_VDD_SOC(trg) (((trg) * 25) + 800) // 25mV increments from 0.8v

enum DCDC_REG3_BITS {
    DCDC_REG3_BITS_TRG = 0,
    DCDC_REG3_BITS_TARGET_LP = 8,
    DCDC_REG3_BITS_MINPWR_DC_HALFCLK = 24,
    DCDC_REG3_BITS_DISABLE_STEP = 30
};

#define DCDC_REG3_BITMASK_TRG 0b11111

enum DCDC_REG0_BITS {
    DCDC_REG0_BITS_PWD_ZCD = 0,
    DCDC_REG0_BITS_DISABLE_AUTO_CLK_SWITCH,
    DCDC_REG0_BITS_SEL_CLK,
    DCDC_REG0_BITS_PWD_OSC_INT,
    DCDC_REG0_BITS_PWD_CUR_SNS_CMP,
    DCDC_REG0_BITS_CUR_SNS_THRSH,
    DCDC_REG0_BITS_PWD_OVERCUR_DET = 8,
    DCDC_REG0_BITS_OVERCUR_TRIG_ADJ,
    DCDC_REG0_BITS_PWD_CMP_BATT_DET = 11,
    DCDC_REG0_BITS_EN_LP_OVERLOAD_SNS = 16,
    DCDC_REG0_BITS_PWD_HI_VOLT_DET,
    DCDC_REG0_BITS_LP_OVERLOAD_THRSH,
    DCDC_REG0_BITS_LP_OVERLOAD_FREQ_SEL = 20,
    DCDC_REG0_BITS_LP_HIGH_HYS,
    DCDC_REG0_BITS_PWD_CMP_OFFSET = 26,
    DCDC_REG0_BITS_XTALOK_DISABLE,
    DCDC_REG0_BITS_CURRENT_ALERT_RESET,
    DCDC_REG0_BITS_XTAL_24M_OK,
    DCDC_REG0_BITS_STS_DC_OK = 31
};

int dcdc_ctrl_vdd_soc(int mv, bool step, bool wait, bool onlyUp);
#define dcdc_get_vdd_soc() (DCDC_TRG_TO_VDD_SOC((dcdc.reg_3 >> DCDC_REG3_BITS_TRG) & DCDC_REG3_BITMASK_TRG))

#endif